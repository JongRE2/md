

## 쓰레드 구현하는 방법 2가지

1. 유저스페이스에서 구현하는 방법 2. 커널스페이스에서 구현하는방법



### 1. 유저스페이스에서 쓰레드를 구현하는 법.

![image-20201211133811575](C:\Users\user\Desktop\md\os\201016fri\201016_1.png) 

1, 유저스페이스에서 구하는걸 유저레벨쓰레드라고 한다. 이방법은 쓰레드패키지를 유저스페이스에다가 통쨰로 집어넣는것이다. 커널은 쓰레드의 존재에 대해서 모른다. 프로세스의 존재만 안다. 이 방법은 운영체제자체가 쓰레드자체를 지원하지않아도 써먹을수있는 방법이다.

커널스페이스에 커널이 있고 유저스페이스에 동그란 프로세스가 2개 떠있따. 그리고 커널스페이스의 커널은 프로세스의존재만 알고 프로세스의 테이블만 관리한다.  그래서 해당 프로세스의 쓰레드들은 그냥프로세스의 런타임시스템위에서 돌고있는거다.

그러면 이 런타임시스템은 뭐냐!? 바로 쓰레드를 관리하는 프로시저의 모임이다. 그래서 런타임시스템은 쓰레드를 관리하는 프로시저의 모임이다.

그러면 어떤 프로시저가 있을까!?  지난시간에 배웠던 쓰레드_create,쓰레드_exit,쓰레드_wait,쓰레드_yield가 있다. 

그래서 각 프로세스마다 테이블이 있다. 그래서 해당프로세스에 속해있는 쓰레드들을 keeptrack하는거다. 그러면은 이 쓰레드테이블에 entry하나하나, 

entry에는 뭐가 들어있겠쬬? 당연히 per thread item은 들어있을것이다.(10월15일에 나옴.) 그리고 이 쓰레드테이블은 런타임시스템에 의해서 관리가 된다.

![ ](C:\Users\user\Desktop\md\os\201016fri\201016_2.png) 



유저레벨 쓰레드의 장점 :

+  쓰레드를 써포트하지않는 os에서도 이것을 구현해가지고 쓰레드를 구현할수있다.

+ 그리고 쓰레드스위칭이 커널레벨쓰레드보다 빠르다. =>런타임시스템이 쓰레드스위칭을 관리하는데 쓰레드스위칭할떄 유저스페이스에서 스위칭한다. 따라서 커널에 들어가지않는다. 따라서 조금있다가 배울 커널스페이스에서 쓰레드를 구현하는, 커널레벨쓰레드의 경우보다 훨씬 빠르다. 커널레벨쓰레드는 쓰레드스위칭할때 커널을 통해서 한다. 그래서 속도가 느리다.
+ 각 프로세스가  자신의 커스터마이징된 스케쥴링알고리즘을 가질수있다.
+ 스케일링이 좋다.(나중에 나올 커널레벨쓰레드는 커널위에있는 쓰레드를 관리하기때문에 쓰레드테이블도 커널에 있다. 그러면은 앞으로 쓰레드가 얼마나 필요할지 알수가없는데 그것을 관리하는 그런 쓰레드테이블을 미리 커널에 얼마나 확보해야하는지 그부분이 문제가 된다. 근데 유저레벨쓰레드는 그런걱정이 별로 필요없는게 프로세스마다 그 프로세스 안에서 돌고있는 쓰레드들을 관리하는 테이블만 있으면 된다. 그러니깐 프로세스마다 쓰레드테이블이 있기떄문에 scaling이 더 좋다.)

![201016_3](C:\Users\user\Desktop\md\os\201016fri\201016_3.png) 

유저레벨쓰레드의 단점 : 

브로킹시스템을 구현하는게 골칫거리다. 왜냐하면 한 프로세스안에서 한 쓰레드가 브로킹시스템콜을 했을떄(예를 들어서 file_Read) 결국엔 커널입장에서는 

쓰레드하나하나의 존재를 전혀모르기떄문에 이 쓰레드가 속해있는 이 프로세스를 블락상태로 보내게 된다. 그러면은 그 프로세스에 속해있는 다른쓰레드들도 그냥 블락상태로 가게 되는거다. 게네들도 수행할 기회가 없어지게 되는거다.

그래서 이걸 해결하기위한 방법으로 책에서 2가지를 들긴했다. (근데 이걸해도 근본적인 해결책이 되진않는다.)

+ 블락킹시스템콜이 implemented되는 방법!

1> 블락킹시스템콜을 난블락킹시스템콜로 바꾼다.=>이건 os의시스템콜을 뜯어 고쳐야하는거다.(항상 블락킹이 되지않게 고치는거다.키보드를 read를 할때는 이미 사용자가 타이핑을 해서 버퍼에 들어와있으면은 그때 read시스템콜을 하면은 바로 버퍼에서 읽어올테니깐 블락킹이 안될것이다. 근데 사용자가 아직도 입력을 안하면은 버퍼에 데이터가 안들어왔으니깐 보통블락킹이될꺼다. 그거는 난블락킹시스템콜로 바꾼다는것은 키보드read시스템콜을 했는데 버퍼에 데이터가 없으면은 그래도 바로 리턴을 하는거다.(0을 리턴한다던가) 데이터가 아직안들어왔따 이런식으로해서 블락킹을 아예 안한다는거다.)

2>  wrapper를 쓴다! 예를들어 리눅스시스템콜을 그냥 쓰지말고 새로운 read시스템콜을 read프로시저에 정의를 해서 그안에서 이제 read시스템콜을 하게 하는거다. 그래서 이제 사용자프로그램입장에서는 그 새로만든 read프로시저인 read시스템콜을 콜하게된다. 그러면 그안에서 코딩이 어떻게 되어있냐면은, 일단은

select시스템콜을 먼저 해보는거다. select시스템콜은 내가 이제 앞으로 read시스템콜을했을때 블락이 될지 안될지 결과를 알려주는 그런 시스템콜이다. 그래서 select시스템콜을 먼저 해보고 블락이 되지않을거다!? 라면은 시스템콜을 하고 select시스템콜의 결과가 인제 read시스템콜을 하면 블락될꺼다 라는 결과가 오면은 결국 read시스템콜을 하지않는거다.  그대신 다른 쓰레드에게 cpu를 넘겨준다. 예를들어 thread_yield 이런걸 통해서 양보를 하는거다. 이런식으로 아예 read시스템콜을 기존의 read시스템콜을 콜하지말고 그 read시스템콜을 감싸는 read시스템콜을 만들어서 그안에 select와 read,thread_yield이런코드들을 넣어가지고 그걸 감싸는 read시스템콜을 새로 만드는거다. 이런걸 wrapper라고 한다. 하여간 이런것들도 근본적인 해결책이 되긴 어려운것으로 보이긴한다.

+ 

유저레벨쓰레드에서는 한프로세스에 쓰레드중에 하나가 CPU를 잡아가지고 얘가 이제 수행이되면은 얘는 그 프로세스에 퀀텀이 끝날때까지 사실은 계속 CPU를 차지하게된다. longtime스케쥴러가 중간에 개입해가지고 얘한테 다시 요만큼 작은 퀀텀주고 프로세스에 퀀텀내에서 다시 쪼개가지고 그 런타임스케쥴러 이놈이 얘를 미니퀀텀을 줘가지고 수행시키고, 그다음에 또 프로세스는 다른쓰레드에게 또 미니퀀텀을 줘서 수행시키고 이렇게 하는걸 생각한다면, 이렇게하려면 또 

clock signal을 이용해야한다. 프로세스를 컨트롤줘서 라운드로빈을 수행할때도 clock interrupt가 필요했다. 그러면 얘도 그렇게 해야되는데 그런데 그런것들이 쉽지가 않다. 프로세스에 있는 퀀텀별로 clock signal을 받는거까지는 기본적으로 잘되지만 다시 그 프로세스안에서 쓰레드를 위해가지고 다시 clock signal을 더 세심하게 더 작은 interrupt을 받아서 처리하는게 구현하기가 쉽지가 않다. 그러면은 한쓰레드가 자기가 속한 프로세스의 퀀텀을 다쓰게 냅둘것이냐? 그렇게하기에는 또 그러니깐 어떻게하냐면 이 쓰레드가 CPU를 한번 잡으면은 조금쓰다가 자기가 yield(상황이 여의치않으면 잡고있지말고 cpu를 다른애한테 양보하게 thread_yield같은걸 콜한다.)

그렇게 자발적으로 같은프로세스안의 쓰레드끼리 CPU를 나눠쓰게 그런방법을 써야된다는거다. 그런것들이 고충이라고 지적이 되는거다.



### 2. 커널에서 쓰레드를 구현하는 방법.

![image-20201211150903641](C:\Users\user\Desktop\md\os\201016fri\201016_4.png) 





이경우는 커널이 쓰레드를 관리하는 방법인거다. 그래서 커널이 쓰레드테이블을 가지고 있따. 그리고 유저스페이스에서는 더이상 런타임시스템이 프로세스마다 있지도 않다. 그리고프로세스마다 thread테이블이 있지도 않는다. 그래서 모든 프로세스의 쓰레드들이 커널에서의 저기 나와있는 테이블들에 다 들어가게 되는거다. 그러면은 이 커널레벨쓰레드는 유저레벨쓰레드에 비해서 당연히 장점이 있다. 이 특정프로세스에 쓰레드가 블락킹시스템콜(file read같은것)을 했다고 치자. 그러면은 이제 커널이 이 쓰레드의 존재를 알기때문에 얘를 이제 블락킹상태로 놓고 그다음에 다른 쓰레드한테 기회를 줄수가있다. 다른쓰레드 얘네들을 러닝상태로 놓고 수행하면 된다. 즉 블록킹시스템콜을 하더라도 그 쓰레드가 속해있는 프로세스전체가 블락되지 않는다. 그런장점이 있다. 그게 바로 유저레벨쓰레드의 큰장점이라고 할수있다.

**그래서!!!  nonblocking시스템콜을 특별히 만들필요가 없다 !!! ** ==> 그래서 쓰레드가 블락킹시스템콜을 하더라도 그 쓰레드가 속한 프로세스에 있는 다른쓰레드들이 같이 블락되는일이 없다. 그래서 유저레벨쓰레드와 커널레벨 쓰레드를 봤는데 커널레벨쓰레드는 방금말한 한쓰레드가 블락킹시스템콜을해도  같은프로세스의 다른쓰레드가 블락되지않는 장점이 있는반면 단점은 쓰레드를 create나 terminate할때 유저레벨쓰레드에 비해서 쓰레드operation이 오버헤드가 크다. 

유벌레벨쓰레드의 경우에서는 유저스페이스에서 그냥 런타임라이브러리가 다 해결을 해준다. 쓰레드를 생성할때나 종료할때나 커널을 들어가지않는다. 그러기떄문에 커널레벨쓰레드는 한번 커널을 들어갔다 나와야되기때문에(쓰레드를 생성할때나 종료할때) 오버헤드가 있다.

그리고 결과적으로 유저레벨쓰레드의 장점과 단점이 반대로 커널레벨쓰레드에서는 단점과 장점으로 될수있다!!

![image-20201211152040524](C:\Users\user\Desktop\md\os\201016fri\201016_5.png) ( 이건 그냥 참고)

유저스페이스에서 커널쓰레드 한개가 멀티플로 쓰레드가 되어있다 이게 바로 하이브리드방식인거다.

![image-20201211152203750](C:\Users\user\Desktop\md\os\201016fri\201016_6.png) 

이거의 기본적인 아이디어는 커널이 쓰레드가 블락되었을때 그것을 이제 안다. 쓰레드가 블락킹시스템콜(file read같은거)를 하게되면은 커널이 그것을 이제 알아차려서 쓰레드의 존재를 알게 되서 커널이 그걸 안다음에 얘가 유저스페이스에 있는 그 쓰레드가 속해있는 프로세스의 런타임시스템에게 notify해준다. 즉 니네 프로세스안에 있는 쓰레드중에 한놈, 쓰레드3번이 지금 블락킹시스템콜을했단다! 이런식으로 알려준다. 거기에 file read를 했어~ 이런 구체적인 정보도 알려줄것이다. 그러면은 이제 통보를 받은 그 프로시저의 런타임시스템은 그 해당쓰레드를 blocked상태로 보낸다. 그리고 ready상태에 있는 한놈을 뽑아서 러닝상태로 보낸다. 그러기위해서는 ready상태에 있는 그 선택당한 그 쓰레드에 레지스터라던가 그런것을 러닝하기위해서 reload를 해야하겠다. 그러면은 이때 방금전에 커널이 그 런타임시스템에게 해당쓰레드가 블락킹 시스템콜을 했다고 알려주잖아요?( 쓰레드3번이 블락킹시스템콜에다가 알려준단말이에요?)  그러면 어떤식으로 지나가냐면은 커널이 유저스페이스에 있는 런타임시스템콜을 해서 이루어진다. 그런데 콜이 아랫층에서 윗층으로 이루어지는거다. 소프트웨어레이어라는게 맨밑의 os커널이 있고 그위에 인제 어플리케이션 유료프로그램들이 도는데 지금같은경우에는 커널쪽에서 유저스페이스쪽으로 콜이 일어나는거다. 일반적으로 항상(위에서 아래로) 거꾸로 일어나거든요. 즉 시스템콜이라는것도 유저스페이스에서 커널스페이스로 콜이 일어나는거다. 커널에서!! 유저스페이스로!! 콜이 일어난다!!! 그래서 이것을 UpCall 이라고 한다~!!! 그래서 UpCall을 하고 지금 현재 쓰레드는 지금 런타임시스템이 얘를 blocked상태로 보낼꺼란말이다. 그런데 언젠가는 I/O가 완료가 될것이다. 그러면은 i/o 컴플레션(completion완료)을 커널이 알겠다. 그러면 커널은 다시 런타임시스템에게 UpCall을 통해서 notify를 해준다. UpCall을 통해서 " 야~ 지금 아까 blocked됐던 쓰레드3번 게가 i/o가 완료됐으니깐 게는 이제  cpu를 써도 돼~~" 이렇게 알려주게 된다. 그러면 런타임시스템은 해당 쓰레드를 blocked상태에서 ready상태로 일단 돌릴수있겠다. 그럼 이제 ready상태에서 기달리다가 러닝상태로 또 갈수있으니깐요. 그래서 이런식으로 UpCall들을 하게 된다. 이 방식이 스케쥴러activations이라는 방식이다.

근데!? 이 방식은 결국보면은 소프트웨어레이어가 있을떄 위의 레이어에서 아래레이어로 콜이 되는게 정상인데 이것은 반대로 아래레이어(커널쪽에서) 유저스페이스쪽으로 콜이 일어나는 UpCall을 하고있기때문에 정상적인 소프트웨어 그런 콜구조를 파괴한다.(위반한다.) 그러한 비판이 있다.

![image-20201211153833433](C:\Users\user\Desktop\md\os\201016fri\201016_7.png) 

Pop-up쓰레드란?

보통 외부에서 서버쪽으로 네트워크를 타고 메시지가 들어온다. 그러면은 서버는 그 메시지를 처리하기위해서 쓰레드를 잔뜩 만들어 놓고 그 쓰레드들이 이제 메시지를 받을준비를 한다. 그래서 뭐 receive시스템콜 같은것을해서 쓰레드가 보통 메시지가 오기전까지는 blocked되어있겠따. 그러다가 이제 메시지가 도착을 하면은 블락되어있는놈중에 한놈이 그 receive시스템콜을 했을때 블락되어있을텐데 게가 이제 얘가 블락이 풀리면서 그 메시지를 다시 정리하게 되겠다.(블락상태에서 ready상태로 거쳐서 러닝상태로 들어가서 처리) 그러면은 이제 러닝상태로 갔을때 이 쓰레드의 원래 블락되기전의 상태로 레지스터값이라던가 이런걸 reload를 하겠죠. 그러면은 이게 다 오버헤드이기떄문에 시간이 걸릴것이다. 그래서 이것의 시간을 줄이기위해서 나온게 Pop-up쓰레드다.

Pop-up쓰레드는 그냥 메시지가 들어왔을떄 그떄 바로 쓰레드를 새롭게 만드는거다.(기존쓰레드가 블락되어있다가 ready있던게 running으로 가면서 상태를 reload를 하면서 그렇게 오버헤드를 거치면서 이 메시지를 처리하는게 아니고). fresh start를 하는거다!!



#### 씽글쓰레드코드 ==> 멀티쓰레드코드

![image-20201211154932620](C:\Users\user\Desktop\md\os\201016fri\201016_8.png) 



이런상황을 생각해보자~ 한 프로세스에 쓰레드1과 스레드2가 있다. 그럼 쓰레드1이 access시스템콜을 먼저했다고 해보자. access시스템콜은 그런거다. 현재 어떤특정파일에대한 permission이 있는지에 대해 체크하는거다. 근데 이런 시스템콜을 콜했을때 시스템이 보통 시스템콜을 처리하는동안에 에러상황이 발생하면은 

global variable인 a에 해당하는 errn에 세팅을 해준다. 그래서 그 시스템콜이 리턴되고 났을때 errno를 또 체크해봐가지고 시스템콜을 처리하면서 무슨문제가있었는지 체크해본다. 근데 쓰레드1이 access시스템콜을 하고 그러면은 이제 처리하는동안에 errno가 셋팅이 되었을수도있었겠죠. 그다음에 쓰레드1이 errno를 값을 체크하려고하는데 스케쥴링이 일어나서 쓰레드2로 제어가 넘어간거다. cpu가 넘어간거다. 그래서 스레드2가 수행을 하는데 얘가 수행하다가 얘가 open이라는 시스템콜을 했다. 시스템콜을 했으니깐 결과적으로 중간에 에러사항이 발생하면은 global variable인 errno에다가 값을 또 셋팅이 된다. 그러면은 아까 쓰레드1이 access시스템콜을 해가지고 그게 이제 처리되면서 에러값이 errno에 셋팅이 됐는데 그게 이 쓰레드2가 오픈시스템콜을 함으로써 오픈시스템콜이 수행되는동안에 

에러사항이 발생해가지고 그 에러값이 errno에 들어왔을떄 결국은 오버헤드되겠다. global variable이다. 이 프로세스에서.

어~ 그러기때문에 결과적으로 errno가 overwritten된다는거다. 따라서~!! 다시 스케쥴링이 되서 쓰레드1의 차례가 되서 쓰레드1이 비로서 에러를 체크해보면은 자기가 access시스템콜했을때 셋팅된 errno값이 아니고 옆에 있는 쓰레드2가 open시스템콜을 해서 수행을 하는동안에 overwrite된 그 errno값을 보게 되는거다. 따라서 이것을 해결하기위해서는 다음 아래그림같은 아이디어가 나온거다

![image-20201211162608765](C:\Users\user\Desktop\md\os\201016fri\201016_9.png) 

따라서 이것을 해결하기위해서는 다음과같은 아이디어를 얘기를 한거다. 쓰레드마다 global variable을 따로 관리하자는 얘기다.

그래서 각 쓰레드가 자신만의 global variable을 갖게 되는거다. 즉 이 전체적인 큰 네모를 보면은 

지금 쓰레드1' 코드 ````` 등등 이런식으로 되어있다 . 그러면 결과적으로 이게 이 큰 네모가 이 쓰레드에 속한 프로세스의 address space라고 볼수있겠다.

그래서 이 a부분은 1,2의 text영역이 되는거고, b부분은 1,2프로세스의 stack영역, c부분은 데이터segment로 볼수가 있다!!

그래서 쓰레드마다 자신만의 stack이 갖는다. 그래서 프로세스의 stack속에서 자신만의 stack이 있어야 한다!!!

1,2의 text영역은 자기네들이 쓰는 각자 코드들이 있겠다. 근데 결과적으로 address space를 공유하기떄문에 code(text영역)은 공유가 된다. 그래서 상대편프로세스의 코드도 access할수있다. 1,2의 globals(데이터segment)은 보통 static하기때문에 처음부터 데이터segment에 들어간다. 

#### <span style="color:red">**★그래서 데이터segment의 예를들어 global variable을 따로따로 각 쓰레드마다 들어가게 디자인을 하면은 p16스샷내용의 문제들을 해결할수있다!!!!!!!**</span>













