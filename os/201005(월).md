스케쥴러

컴퓨터가 멀티프로그래밍을 하게 되면서 여러개의 멀티플프로세스들이 cpu를 차지하기위해서 경쟁하게될것이다. 이런 상황이 구체적으로 2개이상의프로세스가 ready상태에 있게되면은 이런일이 발생하게 될것이다. 

근데? CPU가 컴퓨터시스템에 단한개밖에 없다면 이 ready상태에 있는 프로세스들중에 누구를 선택해서 수행할것인가? 누구를 running상태로 둘것인가!?

이러한 이슈들이 생기게될것이다. 어느 프로세스를 선택하는 역할을 하는 스케쥴러가 있는데 이것은 os부분에 있다.

그리고 스케쥴러가 사용하는 알고리즘을 **'스케쥴링알고리즘'**이라고 한다.



옛날에 배치시스템과 time sharing시스템을 사용할떄 CPU가 이제 이런 옛날시스템에서는 굉장히 희귀한 자원이였따.

그래서 스케쥴링알고리즘을 굉장히 현명하고 효율적으로 이걸 만드는데에 굉장히 많은 노력을 기울였다. 그러다가 PC가 생겨났다.

이런 pc를 사용하는 상황에서는 보통은 한개의 active_process만 있게 된다. 우리가 CPU가 굉장히 빨라져가지고 이제는 이 CPU라는게 희귀한 자원이라고 볼수없게 됐따. 

그래서 이런 단순한 pc에서는 스케쥴링이 그렇게 부각되지않았다.

 ![201005_1](C:\Users\user\Desktop\md\os\201005mon\201005_1.png)

하지만 여기서 3번째에 해당하는 High-end networked workstations이나 서버같은경우에는 스케쥴링이 중요시 되고 있었다!! 여러 client프로세스를 상대를 해줘야하기때문에 그런거에 있어서 스케쥴링이 중요한것으로 대두 되었따.

4. Process switching is expensive ===> p1를 running상태에 있다가 이걸 끌어내리고 ready에 있는 애를 running으로 올리는 이러걸 process switching이라고 한다. 그러려면은 running에 기존에 있던애의 상태정보를 register값이라던가 하는곳에 저장을 해야할것이다. 그리고 ready에 있던놈을 그전에 running했을때의 상태정보를 로딩해와서 running을 시킬것이다.

   이렇게 러닝시키기위해서는!?-----> 결국은 운영체제로 들어가야한다.  모드가 user모드에서 커널모드로 바뀐다. 이 모든것들이 expensive하다 라고 말한다. 

   그래서 Process switching은 expensive하다.




### Process Behavior

![201005_2](C:\Users\user\Desktop\md\os\201005mon\201005_2.png) 

Process Behavior=프로세스 행동양태 2가지

a타입 : CPU-bound process(=compute-bound process) --> cpu를 많이 사용하고 i.o요청해서 i.o를 기다리고 cpu를 많이 사용하고 i.o요청해서 기다리고이런식으로 하는거임. 이때 cpu가 사용하는 시간(부분)(그림에서) = CPU burst라고 부르는데 a타입은 'CPU burst'라고 한다.

b타입 : I/O-bound process --><span style="color:red">CPU burst(I/O burst라고 표현하면틀린거임!!!!!!!)</span>가 짧은 타입이다.

 그림에서 선부분은 burst를 가리키는 블락이 아닌, I/O를 기다리는부분이다. 프로세스가 I/O요청을 하고(예를 들어서 file read나 write같은걸 시스템콜했을때)

나서 그러면은 이 시스템콜을 한 프로세스는 Blocked상태로 간다.





### 언제 스케쥴링이 일어나는가?

![image-20201209132128202](C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20201209132128202.png) 





+ 프로세스가 created될때.

  parent process가 fork같은 시스템콜을 해서 child process를 만들수있다. child process만들어진 순간에 clone이 생겨나는거다. 이때

  스케쥴러는 누구를 실행해야하느냐?? --> parent를 계속 수행할까 child를 수행할까 라는 이런걸 결정해야한다.

+ 프로세스를 종료할때.

  프로세스가 러닝상태에 있다가 종료를하게된다고한다. 그러면 ready에 있는 프로세스중에 하나를 뽑아서 러닝으로 올린다.

+ 프로세스가 block될때 .

  프로세스가 러닝상태에있따가 시스템콜을 한다고하자(파일read나 파일write시스템콜). 그러면 프로세스는 blocked상태로 간다. 그러면 누구를 또 ready중에 누구를 러닝으로 올릴것인가

+ I/O 인터럽트가 발생할때.

 어떤프로세스가 러닝에서 수행중이고 있을때 갑자기 CPU쪾으로 I/O디바이스로부터 인터럽트시그널이 들어온거다. 그것은 아마 아~까 어떤 다른프로세스가 파일read 이런 시스템콜을 해서 디스크로부터 파일을 읽어달라고 요청을 했던 이유겠다.

그러면은 그당시에 옛날에 그 프로세스가 blocked상태로 갔을꺼다.  근데 현재 그 i/o가 다 완료가 되고, 완료가 됐다는거는 이제 디스크에서 일으켜진 데이터가 

커널버퍼로 들어오는 그런게 필요한 상황이다. 그러면 이제 어떤일이 일어나냐면은 I/O디바이스 즉, 디스크쪽으로부터 CPU의 인터럽트가 걸린다. 그러면은

인터럽트가 걸리면은 인터럽트벡터(얘는 인터럽트헨들러의 주소를 가지고있다)를 찾아서 그 해당 인터럽트헨들러가 수행된다. 그게 수행되면서 이경우에는 디스크로부터 읽은데이터를 common버퍼로 옮긴다던가 이런게 인터럽트헨들러루틴에 의해서 일어난다. 이런게 다 완료가되면은 인터럽트처리가 다 끝난거다.

글면은 인터럽트헨들링이 끝났으니깐, 지금 이 인터럽트가 걸리는 바람에 현재 러닝상태에 있는프로세스가 갑자기 날벼락을 맞은것처럼 수행이 중지된거다. 

근데 이제 인터럽트헨들러가 다 처리가 됐어. 그러면 어떻게 되는가? 아까 결과적으로 I/O를 요청해서 그 blocked상태로간 프로세스는 더이상 blocked되어이을 이유가없으니깐 ready로 옮겨진다. 그다음에 누굴 running으로 넣어줄것인가?

==> 아까 갑자기 날벼락맞아서 갑자기 중단된 interrupted프로세스를 다시 running으로 놓고 수행을 할것인가? 또는 방금 blocked에 있다가 이 인터럽트헨들러가 수용되는 바람에 ready로 간 프로세스를 running에 넣고 수행할것인가. 또는 뭐 제 3의프로세스를 실행할것인가? 이거는 os스케쥴러알고리즘에 따라 결정이 될것이다. 가장자연스러운것은 날벼락맞은 그 프로세스를 실행시키는게 가장 자연스러워 보이긴할꺼다.

+ 스케쥴링 알고리즘은 clock interrupt를 어떻게 사용하느냐에 따라서 2개의 카테고리로 나뉠수있다.

  + Nonpreemptive스케쥴링알고리즘 : 스케쥴링에 client인터럽트의 도움을 아예 받지 않는다. 프로세스가 한번 러닝상태에서 수행되고있으면은 게는 파일read나 파일write시스템콜을 해서 blocked상태로가기전까지 계속 런하게 냅둔다. 또는 자발적으로 CPU를 내려놓을때까지 계속 런한다.

  + Preemptive 스케쥴링알고리즘 : 프로세스를 한번 러닝상태에 놓고 수행을 한다. 얘는 주어진 시간이 있다. 시간이 다 써가는데 아직도 cpu를 사용해서 쓰고있다. 그러면은 얘는 "너 시간 다 됐다"라고 말해주고 얘를 이제 러닝상태에서 끄집어내린다. 그리고 ready에 있는 다른 프로세스를 러닝상태로 올린다.

    이 Preemptive 스케쥴링알고리즘은 client interrupt를 이용한다. 어떻게 이용하는가?

     -->클락이라는하드웨어가 계속 CPU에 주기적으로 인터럽트를 걸수가있다.(1/60초에 한번씩 걸다던가 등등) 그러면 그때 인터럽트헨들러가 client인터럽트에 의해서 수행이되면은 그 헨들러에서 이런 Preemptive한 스케쥴링알고리즘을 작동을 시킨다.

    예를 들어서 프로세스마다 1/60초로 주어진다고 가정했을때, 그리고 client인터럽트가 1/60초마다 걸린다고 가정한다면,

    그러면 client인터럽트가 걸릴때마다 client헨들러가 수행이 될꺼고 그때 이 프로세스를 러닝상태에서 끄집어내리고, ready상태에 있는 프로세스를 running상태로 올린다.

    만약에 3/60초마다 프로세스에게 준다면 그러면은 client인터럽트가 3번걸릴때 client헨들러가 수행이 될꺼고 그때 이 프로세스를 러닝상태에서 끄집어내리고, ready상태에 있는 프로세스를 running상태로 올린다.

    

    ![image-20201209144051638](C:\Users\user\Desktop\md\os\201005mon\201005_3.png) 

    

  

+ 배치 시스템: job이나프로그램이 수행되는도중에 사용자와 interactive하지않는 시스템이다. 즉 사용자와의 인터럽트가 없는거다. 

  (Nonpreemptive스케쥴링을 쓰거나 preemptive알고리즘을 쓰더라도 각 프로세스에게 주어지는 시간이 굉장히 길다. 그러므로써 프로세스스위칭이

  자주 발생하지않게 하는거다.(=Reduces process ~~) 왜냐하면 시간을 많이 잡아먹어서 비싸기때문이다. 그럼으로써(프로세스스위칭을 적게함으로써) 퍼포먼스를 향상시키려고한다.

+ Interactive시스템 : 사용자와의 인터랙션을 필요로하는 프로세스 또는 job이 수행되는 경우다. preemptive알고리즘을 주로 쓴다. 한프로세스가 CPU를 계속 무한대로 잡아먹는것을 반기를 한다. 그래서 다른프로세스에게도 서비스를 제공을 한다.

+ Real time시스템 : dead line안에 프로세스던 job이 수행이 되어야하는 그런 시스템이다. 리얼타임시스템은 특징이 preemption가 필요로되지않는다는거다.

  ![* ](C:\Users\user\Desktop\md\os\201005mon\201005_4.png) 

+ Batch system

 #### ★시험

<span style="color:red">	**Throughtput - 시간당 완료되는 job의 갯수다. (이 잡의 갯수를 최대화하는게 목적이다.)**</span>

<span style="color:red">**Turnaround Time - 시스템에다가 job이 제출되서 종료될떄까지 걸린시간 (이건 minimize하는게 목적이다.)**</span>

+ Interactive system

  response time  - ~~

+ Real-time system

  

  Predictability - 멀티미디어시스템(비디오플레이나 비디오)에서는 그 비디오가 플레이되는 rate가 있는데 그 rate에 맞춰서 프로세서가 플레이를 해주지않으면은 비디오퀄리티가 저하된다던가 한다. 그래서 사용자들에게 어느정도 predictability(예측가능한행태)를 프로세스가 제공해줘야한다.



### 본격적인 스케쥴링알고리즘

#### Batch시스템에서의 스케쥴링

![image-20201209152106786](C:\Users\user\Desktop\md\os\201005mon\201005_5.png) 

- 이거는 프로세스가 CPU를 요청한 순서대로 CPU를 할당받는다.

- 그래서 ready상태에 있는 프로세스들이 이제 싱글큐 한줄 하나에 쭉~ 줄을 서있는거다. 그래서 Nonpreemtive인거다.

- 러닝상태에있는 프로세스가 block을 하게되면 아까 ready프로세스들에 싱글큐가 있다고 했는데 그 큐에서 제일앞에있는 그 프로세스가 러닝상태로 가게된다

  =FCFC스케쥴링알고리즘

  물론 I/O가 completed되면은 blocked된 프로세스가 나중에 ready상태가 될꺼아니겠어요?  그러면은 게가 blocked상태에서 ready상태로 올텐데 그때는 일반적으로 싱글큐의 마지막에 붙게 된다.

(위 이미지에 단점이 나와있는데 이건참고로만봐라!!! 중요하지않음!!!!!)



![image-20201209153025383](C:\Users\user\Desktop\md\os\201005mon\201005_6.png) 



    + 각프로세스에 런타임이 다 미리알려져있을때 할수가있다
    + optimal average turnaround time을 제공한다.(물론 항상 모든job들이 동시에 available해야한다.(동시에 다 시스템에 도착해있어야한다.))

예제> 그림을 단순하게 A,B,C,D로 수행을 하면은 A의 turnaround time(제출된시점으로부터 완료된 시점까지 걸린시간.)

(모든게 다 시간0에 A,B,C,D가 다 기술 됐다고 보는거다.)

이 SJF알고리즘은 모든애가 다 처음에  동시에 다 도착해있어야한다. 그떄 sjf를 돌렸을때 optimal한 average turnaround time이 나온다는 보장이 있따.

모든게 다 타임이 처음0에서 available해야하니깐(이떄 다 도착해있어야하니깐 )  A는 abcd~순으로 0~8수행했다고 보자. 그러면 a는 ~~<37분>

<img src="C:\Users\user\Desktop\md\os\201005mon\201005_7.png.jpg" alt="201005_7.png" style="zoom:67%;" />

SJF를 구할때 필수조건!! 모든잡이 동시에 available해야지 sjf가 최소average타임을 제공한다는거다. 동시에 못하면 최소average타임이 안나온다!!

(책에도 예제있으니깐 한번해봐라~/ 2/6/4/5/6)

![201005_8.png](C:\Users\user\Desktop\md\os\201005mon\201005_8.png.jpg)



