 

![image-20201209102708070](C:\Users\user\Desktop\md\os\200928mon\200928_2.png) 

먹을때는 반드시 포크가 2개가 필요하고 한번잡을때는 한개씩 잡을수있는 상황이다.

이런상황에서 데드락을 일으키지않는 상황을 고안해야한다.

==>A프로세스는 B프로세스의 리소스를 기다리고 B프로세스는 A프로세스의 리소스를 기다린다. 진행을 못하고 계속 기다리게 되는 상황이다.



### Dead Lock을 해결하기위한 첫번째 Solution(하나도 안좋음)

![200928_1](C:\Users\user\Desktop\md\os\200928mon\200928_1.png) 

다섯개의 프로세스가 동시에 philosopher()를 호출해서 동시에 think()호출하고 동시에 반복문을 돌면은 왼쪽포크듣는것까지는 모두 실행할수있지만

오른쪽fork를 드는거는 서로 진행을 못하게 될것이다.

결과===>> 어떤 프로세스도 진행을 못하는 **Dead Lock**이 발생한다.

![image-20201209103236498](C:\Users\user\Desktop\md\os\200928mon\200928_3.png) 

위의 상황을 해결하기위한 Solution들.

2. 오른쪽포크 이용가능한지 봤다가 이용할수없다면 왼쪽포크를 내려놓는다. 그리고 시간을 기다리고 근데 이것도 재수가 없으면 5개프로세스가 동시에 왼쪽포크를 듣고 오른쪽포크가 없으면 계속 똑같이 동시에 내리고, 모든프로세스가 동시에 실행되면 첫번째랑 별로 다를게 없다.

   ====>starvation을 유발한다.

3.  각 프로세스가 기다리는 시간이 2번째와 달리 랜덤타임으로 기달린다. 그래서 모든프로세스가 동시에 시작해도 서로 다른시간에 진행되게 되니깐 무한루프에 빠질일은 거의 없다. 

   ====> 확률이 극히 낮지만 운이안좋으면 아~~~~~~~~주 드문 확률로 무한루프에 빠져서 starvation이 생길수도 있다.

4.  think함수다음에 나오는 statements를 binary세마포어로 감싼다.

![200928_4](C:\Users\user\Desktop\md\os\200928mon\200928_4.png) 

하지만, 실질적으로는퍼포먼스가 좋지는 못하다. 한프로세스가 작업을 하는동안에는 다른 프로세스는 작업을 아예 못한다.



#### 이걸 또!! 개선한게!!!!!!! 5번째 솔루션!!이다

![image-20201209104450964](C:\Users\user\Desktop\md\os\200928mon\200928_5.png) 

+ mutex가 1로 세팅되어있는걸 봐서는 binary세마포어임

+ s[N]에서 s는 세마포어를 의미한다.
+ s[i]는 다 0으로 초기화되어있음.



**※p를 3번으로 시작한다고 가정해보자**

1. think수행--> take_fork(3)수행.
2. take_fork(3)을 수행

 --->down(mutex=1)이 들어가니깐 mutex=0으로 바뀐다.

 test(3)은 if조건문이 만족하면 2개의 state를 수행할수있게 되는데, 조건이 만족하려면

hungry가 참이고 왼쪽,오른쪽 둘다 먹고있지 않으면 내가 이제 state[i]를 hungry상태에서 Eating으로 바꾸고 

아까 초반에  up하면서 0->1이 된다. 리턴하면서 take_fork함수 완료.

	3. eat함수 수행

--->

그전에 !! 3번철학자 왼쪽에 해당하는 2번철학자의 상황을 봐보자~!!그러면 2는 take_fork(2)를 하고있을꺼다.

mutex를 다시 1->0으로 바꾸고 그리고 state(2)=hungry상태로 가고 test를 호출한다. 그러면 if조건을 보면

왼쪽은 Eating상태가 아니라고했는데 오른쪽은 3번p가 먼저 eating하고 있었기에 p2는 if조건문이 거짓이 된다.

그래서 그다음 state 2개를 수행못하고 test함수를 거기서 마치고 리턴하게 된다.

그리고 나서 up(mutex)를 하면서 아까전에 1->0로 바꾼걸 0->1로 바꾼다.

그리고 s[2]는 기존에 0이었는데 down해봤자 여전히 0일것이다. 그러면서 프로세스2는 sleep으로 간다.



p4도 생각마찬가지이다. 제일먼저 실행한 p3때문에 얘도 sleep으로 가게되어있다!!



그러면 다시 p3입장으로 가보자. 아까전에 eat()함수가 다끝났다고 해보자. 그러면 드디어 put_fork()를 호출할것이다.

down(mutex)로 1->0으로 바꾸고 state는 Thinking상태로 바꾸고 

test(left)를 부른다. left니깐 test(3)이 들어가는게 아니라 test(2)가 들어간다.

그러면 아까전에 sleep으로들어가있는 test(2)는 hungry가 맞고 그리고 state의 왼쪽 오른쪽 둘다 Eating하지않는다고 해보자.

그러면 이제 결국 state[2]도 EATING상태가 되진다. 그리고 up(s[2]);를 부른다.

그러면 아까전에 down([s2])에 의해서 s[2]=0이였떤 값이 up에 의해서 1이되면서 꺠어나게 된다.

그러면은 결국 p2은 take_fork(2)에서 리턴하게 된다. 그러면은 p2는 드디어 아까전에 sleep해서 진행못하던애가 eat()함수를 진행할수있께 된다!!



결국 마찬가지로 put_fork(3)에 의해서 실행되는

test(right)에 의해서 test(4)가 실행되면서 p4도 먹을수있게 된다.(물론 p4의 오른쪽이 먹고있지않은상황이라는걸 가정했을때다.)



이렇게 되면은!! 동시에 2명의 철학자까지 먹을수있게 되는 상황이 생긴다.

![image-20201209112807544](C:\Users\user\Desktop\md\os\200928mon\200928_6.png) 결국에는 maximum parallelism을 제공하는 알고리즘이다.



