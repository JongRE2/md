12분부터>

![image-20201211101309685](C:\Users\user\Desktop\md\os\201015thur\201015_1.png) 

지금까지는 프로세스에 대해서 배웠다. 프로세스 모델의 핵심은 Resource grouping과 thread of execution 이 2가지다.

프로세스모델

1. 한 프로세스가 자기의 리소스를 가지고 있다. address space,open file, 등등
2.  thread of execution은 직역하면 '실행의 줄'이라고 해석된다. 이것을 keep tracking하기위해선 program counter, register,stack(스택은 콜을 했는데 리턴을 안한 그런 정보를 가지고 있는거다.)이 필요하다.



쓰레드모델

1. 멀티쓰레딩을 수용한다.
2. 
3. 프로세스의 property중에 일부만 필요로 해서 Lightweight process라고도 불린다.



![image-20201211102855247](C:\Users\user\Desktop\md\os\201015thur\201015_2.png) 

(b)가 멀티쓰레딩의 모습이다. 프로세스의 일반적인 자원들은 다 공유한다. address space(text,data,code segment등)를 다 같이 공유한다.

근데 그중에서도 쓰레드만의 관리해야될 property(프로그램카운터,레지스터,stack)이 있다. 얘네는 쓰레드마다 따로따로 관리를 한다.



![image-20201211103534695](C:\Users\user\Desktop\md\os\201015thur\201015_3.png) 

쓰레드간에는 일반적으로 protection하지않는다. 쓰레드들끼리는 서로 협력을 하지, 적대적인관계가 아니기때문에그렇다.

### <span style="color:red">★시험</span>

 이제 이 테이블이 중요한 컨셉이다.

Per process items내용은 같은프로세스안에 쓰레드들끼리 공유하는 아이템들이다.

기존의 전통적인 프로세스처럼 쓰레드도 state(러닝,block,ready)를 가질수있다.

쓰레드에서의 stack이라는게 뭔가? 일반적으로 호출된 프로시저(아직 리턴은 안한). 각 프로시저당 하개의 프레임을 가지고있다. 결국은 프레임하나당 프로시저의 로컬variables와 return address를 가지고 있따.

각 쓰레드들은 서로 다른프로시저들을 콜한다. 그래서 다른 execution history를 가진다. 그래서 콜한 프로시저에 대한 정보를 담고있는 stack도 각자 있어야 한다.

그래서 자신만의 stack을 가지는거다.

![image-20201211104231823](C:\Users\user\Desktop\md\os\201015thur\201015_4.png) 

쓰레드관련한 라이브러리프로시저에 대한 설명이다.

멀티쓰레딩환경에서는 보통 프로세스가 처음 시작할떄는 싱글쓰레드로 시작을 한다. 근데 거기서 이제 새로운 쓰레드를 thread_create같은것을 통해서 구한다.

thtead_wait : 이것을 콜한 쓰레드가 어떤 특정쓰레드가 exit할때까지 콜한 쓰레드를 블락한다. exit하게되면 block이 풀릴것이다. 그러면은 thread_wait를 한 쓰레드는 ready상태를 거쳐서 나중에 running할수있을것이다.

thread_yield : 쓰레드가 cpu를 자발적으로 포기하게 해주는 함수다. 그러므로써 다른 쓰레드를 러닝상태로 보낼수있게 해주는거다.

![image-20201211110814772](C:\Users\user\Desktop\md\os\201015thur\201015_5.png) 

왜 멀티쓰레드를 생각하게 됐느냐?

+ 상당수의 애플리케이션에서, 한 app안에 멀티플activities가 한꺼번에 일어난다. 그래서 각 activity를 한 쓰레드로 매핑을 해서 프로그래밍을 하면은 굉장히 프로그래밍하기가 단순하고 명료해질것이다.

+ 쓰레드는 create하고 destroy하는게 프로세스보다 쉽다. 프로세스인 경우에는 Per process items가 굉장히 많았다. 근데 쓰레드는 상대적으로 적었다. 그래서 만들거나 없앨떄 프로세스보다 훨씬 쉽다.
+ 한 프로세스안에서 쓰레드를 여러개 만들어서 한쓰레드가 I/o관련된 시스템콜을 해서 기다리고있다 lock이 된다고 하면은 다른 쓰레드가 또 cpu를 이용해서 일을 하면 된다. 이렇게 하게되면은 performance가 좋아질것이다.
+ 쓰레드로 프로그래밍을 한것은 실제 수행할때 쓰레드하나를 이 컴퓨터하드웨어가 멀티플CPU를 써포트한다면은 쓰레드하나를 cpu하나에 이렇게 할당해준다. 이렇게 되면은 진정한 parallelism을 만들어낼수있다.

![image-20201211110837398](C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20201211110837398.png) 





쓰레드가 유용한 경우 (1)

워드프로세서를 3개의 쓰레드로 프로그래밍 한경우다.

키보드로 연결된 지렁이는 키보드로부터 입력을 받는 쓰레드라고할수있겠다. 사용자와 계속 인터렉션하는거다.=>interactive thread

사용자가 문서에 어떤 내용을 삭제하거나 새로운 내용삽입하거나 페이지내용이 바뀌는것을 처리해주는것을 하는애 => Reformatting thread

edit한 내용을 만약을 대비해서 주기적으로 디스크에다가 써주는것을 하는 쓰레드 => disk-backup thread

책에서 드는 예제> 

만약에 멀티쓰레딩으로 워드프로세서로 웹을 구현하지않고 기존의 전통방식대로 싱글쓰레드를 가진 프로세스로 구현을 한다면

사용자가 800페이지에서 어떤라인을 삭제했다고 쳐보자. 그러면은 그다음에 첫번째페이지를 위아래로 왔다갔다하면서 업데이트등이나 수정내용을 확인하고 또 p600으로 이동하려고 하고 그럴떄 싱글쓰레드인 워드프로세서인 경우에는 사용자가 요청한 리포맷을 600페이지까지 수정한후에야 p600페이지를 보여주게된다.

![image-20201211111707662](C:\Users\user\Desktop\md\os\201015thur\201015_6.png) 

각자 받은 일감을 처리하는 

3번이 쓰레드인데 일감을 나눠주는 쓰레드이다. 2번의 3개의 쓰레드는 각자 받은 일감을 처리하는 쓰레드들이다. 외부인 브라우저클라이언트로부터 특정웹페이지를 보여줘!라는 요청이 들어올것이다.(Network connection을 통해서 들어온다.) 그러면 처음에 이걸 3에서 받아가지고 2에게 일을 나눠준다.



(a)는 dispacter쓰레드가 하는일이고, (b)는 Worker 쓰레드가 하는일이다.

(a)코드를 보면, 무한루프를 돌면서 네트워크로 부터 get_next_request로 요청을 가져온다. 그 요청이 아마도 웹페이지의 주소같은거일꺼다. 이걸 buf로 받을것이다.그다음에 handoff_work()를 수행하면 worker쓰레드에게 일을 넘겨주게 될것이다.



그러면 (b)에서는 wait_for_work()로 일감을 기다린다. 그래서 일감이 넘겨받아지면은 look_for_page_in_cache()를 수행하게 되는데 이함수는 buf가 가리키는 그 컨텐츠가 캐시에 있는지 확인하고 있으면 이 함수의 2번째 파라미터인 &page로 들어갈것이다. 없으면 뭐 여기에 null이 들어가던가 할것이다.

그래서 이제 조건문 if(look_for_page_in_cache()) 로써, 캐시에 없었다로 판명나면 if조건문으로 들어가서 read_page_from_disk 로 인해 disk로부터 읽어서 page에 넣는다. 캐시에서 읽어서 페이지에 넣던, 디스크에서 읽어서 디스크에 넣던 페이지에 컨텐츠가 들어가게 될꺼고 결국 마지막에 페이지를 리턴하게 될꺼다!!



