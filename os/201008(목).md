![image-20201209170435484](C:\Users\user\Desktop\md\os\201008thur\201008_1.png) 

남아있는 실행시간이 제일 짧은놈을 선택해서 먼저 실행한다.

![image-20201209170908206](C:\Users\user\Desktop\md\os\201008thur\201008_2.png) 

Bactch시스템은 스케쥴링이 3가지있따.

1.Admission스케쥴러

+ job이 시스템에 도착을 하면은 input큐에 처음에 들어가게되고 거기서 한놈한놈씩 메인메모리로 올린다.

2.CPU스케쥴러(요즘하고있는건 CPU스케쥴러를 한다.)

+ CPU스케쥴러 : ready상태에 있는 프로세스중에 한놈을 선택하고 게를 러닝상태로 옮긴다.

3.Memory스케쥴러 

+ 메인메모리에 새로운프로세스를 넣어야하는데 메모리에 자리가 없다 그러면 기존에 들어있던 한놈을 끄집어내서 내보낸다.(누구를 메인메모리에서 디스크쪽으로 추출(swap out할것인지 Memory스케쥴러가 한다. ))



### interactive시스템의 스케쥴링

![image-20201209172150149](C:\Users\user\Desktop\md\os\201008thur\201008_3.png) 

#### 1.라운드로빈스케쥴링

라운드로빈스케쥴링은 굉장히 심플한 컨셉이다.(라운드로빈스케쥴링는 list of runnable processes인 큐만 관리하면 된다.)



#### ★시험

![201008_4](C:\Users\user\Desktop\md\os\201008thur\201008_4.png)





#### 2. Priority스케쥴링

![image-20201209174742551](C:\Users\user\Desktop\md\os\201008thur\201008_5.png) 

말 그대로 프로세스에게 priority(우선순위)를 줘서 가장 높은 priority를 가진 프로세스를 먼저 실행시킨다.



문제점?

제일 priority가 높은 프로세스가 계속 CPU를 무한히 수행하는것(CPU를 독점하는것)을 막기 위해서 대처방법

(책에서 2가지정도 소개함)

1. 현재수행중인 프로세스의priority clock tick마다 낮춘다.   클락하드웨어에서 cpu로(도?) 시그널인터럽트가 걸릴떄마다 낮춘다. 

그렇게 조금씩 낮아지다가 다음으로 높은 priority를 가진 프로세스보다 더 낮아지게되면은 그 프로세스는 context스위치를 한다.

2. 각 프로세스에게 maximum time 퀀텀을 준다. 그래서 priority가 높다해도 이 maximum time퀀텀을 지나면은 러닝상태에서 끄집어 내린다.



#### Priority Assignment(우선순위를 주는방법)

+ Static(프로세스를 시작하기전에 정적으로 주는거다.)

  + 사용자 기준으로. (책에 나온 예제로는, 학교같은 기관에서는 학장님프로세스를 제일 높은 우선순위로 주고 학생들의 프로세스를 가장낮게 준다던가.

    군대에서는 계급별로. / price기준에서는 상업적인 컴퓨터센터에서 시간당 돈을 더 많이 내는사람한테 우선순위를 높게 준다. )

+ Dynamic(프로세스를 실행하면서 실행중간에 priority를 조정하는거임(먼저 ))

  + priority를 다이나믹하게 주는것이다.(책의 예제로는, 수행하면서 I/O바운드프로세스에게 좋은 서비스를 주자. 프로세스들이 멀티프로그래밍을 하면 메모리에 들어있다. 근데 그중에 I/O바운드프로세스는  short CPU burst의 특징을 가지고있으니깐 한번 CPU쓸때 조금씩 밖에 안쓴다.  그래서 빨리 메모리에서 내보내서 시스템이 부담을 털어내는거다. CPU를 요청할떄 우선순위를 높게해서 빨리 우선적으로 CPU를 줘버리면은 어짜피 얘네는 조금만 쓰니깐 CPU달라고할때 우선순위를 높게 줘가지고 얘네들을 빨리 종료시키는것에 목적이 있는거다.)

  + 그러면은 어떻게 하면은 I/O바운드프로세스에게 다이나믹하게 굿서비스를 제공하느냐? priority를 수행하면서 프로세스들의 priority를 1/f로 세팅을 해준다.(f는 뭔가?  프로세스가 사용한 가장 마지막퀀텀의 fraction 즉,  이 시스템에서 스케쥴링이 퀀텀을 50ms로 쓴다고 해보자. 그러면은 프로세스가 25ms밖에 안썼다고해보자. 그러면은 fraction을 계산해보면은 25/50가 된다. 즉 f는 1/2라는 소리다. 그러면 priority를 1/f이라고 하니깐 이 값은 2가 된다. 즉 주어진 퀀텀에서 반만 쓰면서 priority가 2가 된다. 근데 예를 들어서 퀀텀을 다 쓴애가 있다고 하자. 얘의 f는 1이될것이다.  그러면 priority값을 1을 받은애는 f=1이여서 아까 반만 쓴애의 f=1/2보다 값이 크다. f값이 큰애가 우선순위가 높다고 하자 ㅇ.ㅇ! 그리고 priority를 2로 받은놈은 퀀텀의 반밖에 안쓴거다. 얘네들은  I/O바운드 하다고 보는거다. 다쓴애보다는 CPU를 적게 쓴놈으로 보는거다. 아까 50을 줬는데 50을 다쓴애는 CPU바운드라고 불리는거다.(=Long cpu burst를 말하는거다.)  예를 들은 철학이 I/o바운드프로세스에게 좋은 서비스를 제공하재잖아. 그러면 게네들한테 priority를 높게 줘야하잖아. 그러면 다이나믹하게 1/f로 주면은 I/O바운드프로세스(priority)가 높아진다.)
  
    
  
  ![image-20201209214138717](C:\Users\user\Desktop\md\os\201008thur\201008_6.png) 
  
  방금전까지는 프로세스별로 priority를 줬다. 근데 이제는 클래스별로 priority를 주는걸 얘기하고 있다.
  
  그래서 priority 4class부터 priority 1class까지 있다. 그러면은 priority4가 제일 높은 클래스다.
  
  그러면은 이 스케쥴링은 어떻게 돌아가냐면, 클래스끼리는 priority있는거고 클래스안에서는 라운드로빈스케쥴링을하는거다. 맨위에있는 클래스부터 라운드로빈으로 돌린다.(각 퀀텀이 있겠따.) 그러다가 4클래스큐가 텅비어지면 그다음priority클래스에 있는 프로세스들을 라운드로빈으로 돌린다.
  
  그래서 그것도 텅비게되면은 그다음 클래스의 priority를 또 한다. 
  
  근데 걱정되는부분은!!아래쪽 클래스에 있는 프로세스일수록 굶어죽을 확률이 높을것이다. 그래서 중간에 그런걸 조절해줘야한다는 adjusted내용이 나온다.





그다음에 멀티플큐알고리즘은 지금 CTSS라는 62년도에 등장하는 시스템에서 쓰였던거다.(위 그림에 나온 방식과 상당히 흡사하긴 하지만 조금 다르다.)



![image-20201209220954422](C:\Users\user\Desktop\md\os\201008thur\201008_7.png) 

CTSS

1.메모리가 작아서 프로세스가 메모리에 한놈밖에 못들어간다. 그렇기떄문에 cpu바운드프로세스에게 퀀텀을 길게 주는게 효율적이다.(cpu바운드프로세스는 long cpu burst로써 cpu를 많이 쓴다. 근데 얘네들은 라지퀀텀이 아니고 작은퀀텀을 주면은 작고 context스위칭이 많이 일어난다. 그러면 어떻게되냐면 메모리는 프로세스1개밖에 못들어가니깐 프로세스스위치로 일을 할떄마다 보조기억장치에서 가지고 와야한다. 이게 시간이 엄청 걸릴꺼다. 그러니깐 cpu바운드프로세스한테는 한번 cpu잡으면 그냥 오래사용하게 라지퀀텀을 주자고 생각하게 된거다. 그렇게되면은 모든프로세스에게 라지퀀텀을 주면은 response time이 나빠진다는거다.

그래서 고민에 빠지게된거다. 그래서 이 멀티플큐라는 알고리즘이 도입이 된거다. 여기서 일단 priority프로세스를 셋업을 한다. 

이렇게 셋업을 한다음에 제일 높은 클래스에있는프로세스를 한퀀텀씩 라운드로빈을 실행을 한다. 그리고 다음클래스에 있는 프로세스들은 퀀텀이 2개다.

그다음 클래스에 있는 프로세스들은 4퀀텀을 갖게 된다. 위 영문스샷처럼 1,2,4,8~ 이런식으로 갖게 되는거다.

![image-20201209221731239](C:\Users\user\Desktop\md\os\201008thur\201008_8.png) 

근데 이제 어떤프로세스가 자기한테 주어진 퀀텀을 다쓰면 한클래스 내려가게된다.(=moved down one class)

그래서 A에 있는 프로세스처럼 거기위치는 1퀀텀을 할당받는다. 1퀀텀이 시간이 지나도록 아직도 CPU를 쓰고있다 그러면 어떻게되냐면 자기클래스의 뒤로 가지않고 화살표①처럼 자기아래클래스 뒤로 간다. 이런식으로 이제 작동을 한다. 여기서도 이제 CPU를 차지하게 되서 2퀀텀을 다썼는데도 그순간에서도 CPU를 쓰고있다!? 그러면 얘도 또 ②처럼 그다음 클래스의 끝으로 간다. 

그러면 이제 예를 들어보겠다.  프로세스가 있었다. 근데 얘는 종료할때까지 cpu를 100퀀텀을 써야된다. 그러면은 처음에 얘는 맨위에서부터 시작해야한다. 맨위에서 1퀀텀을 받겠고 그다음에 2퀀텀, 이런식으로 계속 내려가가지고 전체합한게 100이 되야하는거다. 1,2,4,8, 16, 32까지해도 100이 아직은 안된다. 따라서 64퀀텀짜리까지도 내려가고 거기서 100까지 채울수있는 37까지만 쓰고 종료할꺼다. 이러식으로 얘는 수행이 될꺼다.

 그러면 여기서 context switching이 몇번일어나냐를 책에서 따졌는데 처음수행되는것도 context switching으로 생각을 하면은 1,2,4,8,16,32,64까지 하면 7번을 한다. 이것은 단순한 pure라운드로빈알고리즘 퀀텀하나짜리를 썼을떄는 100퀀텀을 썼을때는 물론 100번의 context switching을 필요했을거다. 근데 얘는 7번만 하면 된다. 따라서 CTSS가 고민한다는 문제가 1번과 2번이 있었는데 그중에 1번. 어~~.. 얘네는 100퀀텀이니깐 CPU를 많이쓴다고 봤을때 cpu바운드프로세스인데

cpu바운드프로세스에게 퀀텀을 많이주는게 유리하다고 생각했었잖아요? 많이 준거죠. 계속 일만준게 아니고 클래스는 내려가지만 8,16,32 막판에는 64까지 주는거잖아요. 그르니깐 cpu바운드프로세스는 점점 인내심을 가지고 있으면은 퀀텀을 점점 큰것을 받기시작한다. 그래서 결국 1번의 요구사항을 어느정도 만족하게 되는거다.

)

2. 모든프로세스에게 퀀텀을 다 크게 줘버리면은 response time이 나빠진다 라고 되어있다.

   이 프로세스가 계속 시간이 지나면서 priority큐가 아래클래스로 내려가게된다. 그러면 결과적으로 위쪽에 있는 priority클래스에있는 프로세스에게 밀려가지고 자주 수행은못될것이다. 따라서 CPU를 차지하는것은 짧고 위쪽에 있는 interactive한 프로세스들이 차지하게 된다. 따라서 이런식으로하면은

이 2.를 해결한다는건데 좀더 자세히 들어가보면은  이런부분이 있따. 이거를 더 정확히 이해하려면은 알고리즘에서 책에는 나오지않았지만 멀티풀큐알고리즘에서는 지금 퀀텀이 다 지나도록 cpu를 쓰고있으면은 아래 priority클래스로 강등된다고했는데,

 이런경우가 있다. priority4에서 어떤프로세스가 차지했다고 해보자. 그러면 얘가 1퀀텀이 다 되지도 않았는데 I/O리퀘스트(파일read라던가 파일wirte같은 시스템콜)를하게 된다. 그러면 이 프로세스는 running상태였다가 blocked상태고 가게 된다.  그다음에 언제가는 I/O가 완료가 되면은,  프로세스는 blocked상태에 있다가 언젠가 ready상태로 갈텐데 이 ready상태로 가게되면은 강등되지않고 원래 자기가 있었던 priority4의 끝으로 가게 된다. 그래서 여기에 있다가 자기가 또 그 priority3에서 맨앞으로 오면은 자기가 CPU차지가게 되고 그럴꺼다. 따라서 이것은 어떤의미냐하면은 어떤프로세스 I/o바운드프로세스라면(즉 short cpu burst라면) 퀀텁을 쓰기도 전에 자꾸 blocked상태로 갔다가 ready상태로 돌아오면서 다시 원래있었던 priority큐로 돌아오는 상황이 되는거다. 계속 i/o바운드프로세스들은 높은 priority가 유지가 되는거다. 그래서 사용자와 interactive한 프로세스들이 사용자와 입력을 주고 받기떄문에,출력시스템콜을 하기떄문에 이런애들은 i/o바운드프로세스(이런 short interactive프로세스) 들은 높은 priority에 살아남게 된다. 그리고 cpu바운드프로세스(100퀀덤짜리cpu를필요로하는예)들은 i/o만하지않고 cpu만 주구장창 100퀀텀을필요로하고 그게 이제 충족이 되야지만 얘는 끝나는애다. 얘는 결과적으로 그 priority클래스의 퀀텀을 다 쓸때까지도 계속 cpu를 잡고있는놈이기때문에 얘는 cpu바운드인놈이고 얘는 자꾸 강등을 시킨다. 단! 강등을시키면서 퀀텀은 2배로 많이 주는거다! 그래서 얘는 강등이 되면서 결과적으로는 i/o바운드프로세스(short interactive 프로세스)에게 계속 결과적으로는 cpu를 넘겨주게 된다. 자기는 자주차지하지못하게되는거다. 그러므로써 CTSS의 고민 2번의 내용들이 어느정도 해결이 되는거다. short interactive processes들은 response time이 좋다.(높은 priority클래스에 계속 남게되니깐 좋은거다.)



//그리고 그냥 참고로 라운드로빈스케쥴링에는 퀀텀얘기를 처음했는데 보통은 책에서 말하는 시간은 20~50ms이다.



지현우학생질문> multiple queues에서 프로세스가 priority queues를 내려가면서 더 적게 실행되서 뭐가 좋다는건가요? 뒤에 부분은 이해가 잘 안갑니다.

교수님 답 : 더 적게 실행됨으로써 short interactive process(즉 i/o바운드프로세스)에게 cpu를 양보함으로써 그 게네들(i/o바운드프로세스들)이 response time이 계속 좋아지게 해준다는거다. 얘는 밀려서 게네들한테 자리를 양보해주는거다. 얘는 더이상 높은 priority에 남아있지않잖아요. 



 













