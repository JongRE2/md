GROUP BY개념에서 보여줘야될 selection list는 칼람명을 그대로 썼을경우에는 GROUP BY의 리스트에 존재해야하고 아니면은 aggregate operator의 인자로서 존재해야한다.

ASSERTION :  테이블결과에 대해서 만약에 다합쳐놓고 봤을때 sailors수와 boats의수를 합쳐서 100미만인지를 체크하는것은 쿼리할때 결정되는게 아니라 

쿼리하고난다음에 테이블의 결과를놓고 봤을때 ASSERTION을 쓰는거다.

<img src="C:\Users\user\Desktop\md\(윤영)데이터베이스\201110_tue\201110_1.png" alt="image-20201207191751087" style="zoom:67%;" /> 

쿼리에 대해서는 CONSTRAINT라고 얘기를 하면 된다.(앞에서 모델링할때는할수없었던 기능인데 ASSERTION하고 CHECK기능을 이용해가지고  데이터의 integrity를 항상 체크해줄수가있다.)

<img src="C:\Users\user\Desktop\md\(윤영)데이터베이스\201110_tue\201110_3.png" alt="image-20201207233857788" style="zoom:67%;" /> 

INSERT가 일어나면은 SAILORS를 우리가 NewSailors라고 우리가 얘기하고 각 Sailors별로 18세이하인 애들은 YoungSailors에 다시 넣는다!!

===>YoungSailors들로만 새로 추린다 는 느낌인거다!!

#### ※Trigger쓸때 조심해야한다!!

------------

On Update(또는 on delete) : 내가 참조하고있는 테이블이 만약에 업데이트(on delete)가 일어났으면 참조하는쪽에서 어떻게 된다?

 ==> 참조하는쪽에서 default action인 No Action이 일어난다. 왜냐하면 다른 테이블이 지금 현재 참조하고있기떄문에 함부로 지우지말라는 얘기다.

on update no action / on delete no action [이거 실습하는 시간 가질꺼임 ㅎㅎ]



## <복습 끝> + 해싱복습도했지만 필기 생략함

-------------------

Load balancing기법 : 서버를 추가하게 되면 가상노드를 가지고 데이터가 자기가 담당하는 범위를 균등하게 나누려는 것

우리가 기억해야할것 : 가상노드(virtual node)라는것은 해시값의 범위를 균등하게 분할하게 하려고 한다!!



우리가 지금까지 이런 새로운 consistent hashing같은걸 고안하는 이유는!! 환경이 변할때 데이터의 위치를 최대한 덜 움직이게 하려는게 목적이다





### <30분>확장성(Scalability)의 문제는 여전히 존재한다!!

데이터가 어느한쪽으로 몰려지면 그러면은 그 서버에 유난히 질의가 많아져서 그 서버가 과부하가 될 확률이 높다. 그래서 사용자의 접속도 최대한 분살을 시켜서 

해야한다!!

근데!!? 데이터가 분할이 되서 확장성있게 저장이 되고있지만 우리가 질의하는데의 차원에 있어서는 확장성의 문제가 있다!!

우리가 아까 말했듯이 데이터를 해싱을 하면 ID값이 나올거다. 그러면 이 ID값은 실제 어느서버에 존재하는지를 알아야한다.

예전에 유명한 검색시스템중에 하나의 예가 Napster, 소리바다 같은게 있다. 이 시스템들은 peer to peer로 주고 받되 검색은 중앙에서 하는 형태다!!

어떤애가 어떤조각을 갖고있다 라는것이 중앙검색서버에서 이루어진다. 어떤 특정데이터가 어디에 존재하는지는중앙에서 얘기를해주는거다.

<img src="C:\Users\user\Desktop\md\(윤영)데이터베이스\201110_tue\201110_4.png" alt="image-20201208010526289" style="zoom:67%;" /> 

근데 이 중앙검색서버를 보게되면은 Scalability문제도 있고 이 중앙서버가 죽으면 다 끝난다. 데이터를 찾을수없게되버린다.

그러면 어떻게 해야할까?

===> 무식한방법이 있따.

<img src="C:\Users\user\Desktop\md\(윤영)데이터베이스\201110_tue\201110_5.png" alt="image-20201208011242738" style="zoom:67%;" /> 

 내가 어느서버IP를 알게됐다. 근데 데이터가 실제로 내가 원하는 데이터가 들어있는지는 모른다.

그래서 어떻게 하냐면은 클라이언트가 이 a서버에 접속을 했다. 중앙에 있는 검색시스템이 없다고 치자.

글면 어떻게하면은 분산된 상황에서도 검색을 할수있냐 이렇게 의문을 가지는거다. 데이터 D가 어디에 있는지를 모른다.

그런데 내가!!? 어떤 IP주소를 알면 그 IP로 접속은 할수있다. 그러면은 한정적으로 사용자입장에서는 모든 서버의IP를 알고있는건 아니고

아주 한정된 애들만 알고있다. 그러면 어떻게하면 되냐? !!

서버한테 한번 물어보는거다. a서버한테  " 너 데이터D 있니~?"라고 묻고 없다고 하면 이웃서버로 가서  " 너 데이터D 있니~?"이런식으로 계속 꼬리에 꼬리를 물면서 물어보면서 찾는다. 이게 가장 무식한 방법이다.

==> 그래서 시간복잡도가 서버의수 n만큼 걸리므로 O(n)이 걸린다. 물론!! 중앙검색시스템을 두게 되면은 한번에 O(1)만에 찾을수있다. 근데 위에서 말한 이거 하나가 문제가 생기면 그냥 끝나는방법이다.

그러면은 절충안은 없을까? 라고 생각할수있다. 근데 우리가 시간복잡도를 기준으로 절충안을 생각하다보면 O(logN) 이런게 생각날거다.

이러한 고민의 결과가 뭐냐아!!?



#### ==> DHT (Distrbuted Hash Table)이다.

<img src="C:\Users\user\Desktop\md\(윤영)데이터베이스\201110_tue\201110_6.png" alt="image-20201208012021928" style="zoom:67%;" /> 

각 이웃은 옆의 이웃정보만 가지고 있는게 아니라 조금더 멀리떨어져있는 이웃들정보도 갖고 있다. 근데 이런 좀떨어진 이웃정보를 어떻게 갖고있냐?

==> 위이미지의 A라는 식에 따라서 노드가 전체서버에서 일부만 갖고있는거다.

아까전에 말한 중앙처리시스템은 중앙서버가 모든 노드의 정보를 다 갖고있을것이다. 그런데 각 노드는 자기의 이웃의 일부정보만을 갖고있다. 근데 어떤방식으로 가지고 있다?? A라는식에 따라서 일부의 이웃의 정보를 갖고 있는거다!!

<img src="C:\Users\user\Desktop\md\(윤영)데이터베이스\201110_tue\201110_7.png" alt="image-20201208012756182" style="zoom:67%;" /> 

ID2한테 물어봤는데 얘는 7이 없다. ID2는 3 , 5 , 8이라는 이웃을 가지고있는데 7을 가질수있는 서버는 이 찾는 key값보다 큰 ID중에서 가장큰 ID가 된다!!

만약에!!? ID2의 이웃은 3, 5만 있다고 하자. 그러면 7보다 큰 ID값의 이웃이 없기떄문에 7을 가질수있는 이웃이 없는거다!!

#### 좀더 구체적인 예를 들어보자!!

id2의 이웃이 3, 5인데 key값 7보다 큰 이웃ID는 없지만 찾기위한 방법으로 이웃중 가장큰 ID인 5한테물어본다. 그러면 ID5는 5의 이웃인 7, 9, 12에서

key값7 보다 큰 ID중에서 찾는데 9가 가지고 있는걸 발견하게되면 찾는게 완료된다.

 근데!!? 왜 9에서 있냐고 판단되냐면은 9가 5에서 9까지의 내용을 커버담당한다는것을 알고있기때문에 7이 9에 있겠냐라는 사실을 알고 9에다가 물어보는거다.

그래서 결과를 알게되면은 처음에 쿼리패스한 2한테던져주게된다.

====> 이렇게 하면은  O(logN)으로찾을수있게 된다. 물론 빠르기로 봤을때는중앙검색시스템이 제대로만 되어있다면은 제일빨리 찾을수있는 시스템일거다.

근데 중앙검색시스템은 중앙서버가 죽으면 모든 정보도 다 죽게 되기때문에 가용성측면에서 우리가 분산을 시키려고했더니 완전 분산을 하자니 너무 오래 걸린다.

그래서 O(logN)으로찾차~!!라고 나온게 DHT의 솔루션인거다!!





### DHT- Chord

<img src="C:\Users\user\Desktop\md\(윤영)데이터베이스\201110_tue\201110_8.png" alt="image-20201208014256105" style="zoom:67%;" /> 

대량의 서버를 운영하는데에는 적합하지만 데이터를 찾는 Lookup시간이 오래걸린다. 그래서 서버가 5~6개 있고 그러면은 DHT를 쓰는거는 오버다.

그래서 이런경우에는 검색시스템을 이중화해서 쓰는정도면 충분히 될꺼다.



### 그러면 우리는 복제를 어떻게 하는가? (Replication)

복제를 해야하는 이유가 아무리 우리가 데이터를 분산을 했다하더라도 서버가 죽을수있다. 근데 또 서버가 죽을거같으면 거기있던 데이터를 재배치하면

되지않냐고도 물을수있다. 하지만 재배치도 하기전에 죽으면 소용없어진다. 그랬을경우에는내가 어찌할수가없다.

그래서 chord에서는 어떻게 복제를 하냐면은 어떤서버에 대해 자기 이웃서버들에게 데이터를 복제해서 준다. 이런식으로 부분적으로 복제를 할수가 있다.(아래그림이 이에 해당)

<img src="C:\Users\user\Desktop\md\(윤영)데이터베이스\201110_tue\201110_9.png" alt="image-20201208021347287" style="zoom:67%;" /> 



요약하겠다!! 우리가 peer to peer 기반에 데이터베이스management하는게 **NOSQL**이다!!! 

하지만 완전한 P2P는 아니고 약간 하이브리드형인 절충형(중앙+분산)이다.

<img src="C:\Users\user\Desktop\md\(윤영)데이터베이스\201110_tue\201110_10.png" alt="image-20201208021623105" style="zoom:67%;" /> 

virtual node는 해시구간을 균등하게 더 세부적으로 나누는거다. 근데 이 virtual node를 어떻게 나눌꺼냐는것은 시스템마다 다 다르지만

이 원칙은 데이터이동을 최소화하는것이다.

중앙 vs DHT 중에 뭘할지는 서버의 수라던지 복잡도에 따라서 결정하면 될것이다.





<쉬는시간>

-------------

### 

김재윤질문 (59분)> consistent해싱서버 빼기예제에서 s3을 뺄 경우 s1의 담당범위는 3000에서 1000이 되는거 아닌가요? 왜 기존 7500~1000에서

7500~4000이 되는건가요??

교수님 답 > 11월 6일꺼 이미지 오타 수정하심



조규원학생 질문> DHT에서 이웃수를 늘릴수록 검색속도가 빨라지나요?

교수님 대답 : 네~ 좀더 나아지긴할거다.



NOSQL디비가 질의하는 측면에서는 아주 훌륭한 시스템은 아니다.



서지유학생질문(1시4분)> p2p방식보다 DHT방식이 이웃노드에 복제요청을 하기때문에 저장공간을 좀더 많이 사용하나요?

대답 : DHT방식이 좀더 저장공간을 사용하냐 그런문제의 개념이 아니다. p2p라고 하더라도 여전히 복제를 할수있다. 이둘의 차이는 복제를

어느전략으로 하냐의 문제인거다. p2p라는게 완전한 분산형을 얘기하는거라면 p2p도 얼마든지 옆에있는 이웃에 복제를 해도 된다.

그니깐 저장공간은 복제를 했냐의 문제인거다. 

근데 DHT에서 분산을 하다보니깐 여전히 데이터가 조각조각나서 분할이 됐지만 그 조각을 가지고 있는 서버가 죽었을때에 문제가 발생하기떄문에 

복제를 하는거다. 그래서 복제를 하게되면은 그만큼 저장공간을 더 많이 쓰인다.

여러분들 디스크에 RAID설정을 할때 RAID의 수준이 높을수록 가용되는공간이 줄어든다. 그게 왜그러냐면은 복제를 하기때문에 그런거다. 물리적으로 디스크공간을 나눠가지고 복제를 하기떄문이다. 그래서 어쩔수없이 공간이 적어질수밖에 없다. ===> 복제를 하면 그만큼 공간을 많이 쓰게되는거다.



### ※이 복제와 관련되서 최근에 나온게 뭐냐!?

===> 컴퓨터공학개론에서 소개핶었던건데 **블록체인**이다.

이게 제2의 인터넷정도의 파급효과가되는 기술이다!! 라고 얘기를 했지만 그 모든것은 '사기'다. 왜냐하면 가상화폐를 억지로 높이려고 했던 사람들이

뭐 갖갖이 분산시스템기술을 선보이면서 일반인들은 전혀 못알아듣는 얘기를 하면서 정말 안전한 화폐거래기술의 근간이다 라고 얘기를 하면서 엄청 띄었다.

근데 그 모든게 '사기'다!! 근데 알아야하는게 블록체인에 들어가는 분산시스템기술 자체는 여전히 유효한거다.

복제라는 문제가 나와서 말하는게 이 복제를 왜하냐?

==> 가용성의 문제가 있다고 말했다. 일단은 availability측면에서 하는거다. 어디가 죽을지모르니깐 복제를 한다.

그런데!!? 블록체인에서는 Accountbility까지도 그리고 Integrity까지도 고민을 하는게 블록체인이다.

(참고> 블록체인에 관심이 있으면 '사토시논문'을 읽으면 다 끝난다.)





### ★CAP(1시 29분)( Consistency Availability(가용성=복제) Partitiontolerant)

: 이 3가지가 동시에 이루어질수없다라는것이 증명이 됐다. 이 3가지가 만족할수없다라는것이 증명이 됐다.

2개는 된다. (CA 가능 CP가능 AP가능)

#### Availability있을수있으려면 어떻게 해야하는가??!

==> 

1.복제를 해야한다!! 

그리고 복제된 상태에서 일관성(Consistency)을 유지하는것은 가능하다.(C+A)  그렇지만? 여기서 만약에 Partitiontolerant(네트워크끊는것)까지 하고싶다??!

복제하면서 서버가 S1,S2가 있는데 Partitiontolerant에의해 서버(s2)가 한개 끊겼다고 하자. 그러면 s2에 있던 유저는 복제된 내용을 못본다.

그래서 이렇게 3개는 불가능하다.

2. Consistency(일관성)을 유지하고 Partitiontolerant를 유지한다고 본다. 그러면 복제가 되는가???===> 안된다!! 순간적으로 내가 죽었을때 상황을 봤을때는 내가 복제가 완전히 안된다. 일단! C와 P만일경우의 의미는 Partitiontolerant에 의해 네트워크가 죽은 상태이다. 이렇게 네트워크가 죽은상태이면 다른사람한테도 안보여주는거다. s1,s2가 있는데 s2가 죽으면 s1도 안보여주는거다. 그래서 일관성은 유지된다. 한사람이 뭘 보고있는데 다른사람이 못보면은 그러면은 우리다같이 못보자는거다. 대신 순간적으로 복제는 안된다.



우리가 여기서 2개를 취사선택을 잘해야한다!!

만약에 Availability인게 문제다? 그러면은 일관성이던 뭐건 필요없다. 일단 사람들이 SNS같은곳에 접속을 했는데 장애가 일어나면은 신뢰를 못해서 인스타그램을 안하고 틱톡으로 갈수있다. 이러면은 더 큰일이기떄문에 이럴때는 비일관성이더라도 일단은 서비스에 접속은 할수있께 해야한다. 그래서 이럴때는

Availability에다가 Partitiontolerant를 추가한다.



분산시스템은 항상!! 장애! failure가 문제가 된다 특히 Partitiontolerant(네트워크가 죽었을때,서버가 죽었을때)가 일어났을때 이 상황에 대해서 어떻게 대처를 해야하냐는 항상 발생한다!!!!!!!!1





